def predict(u_0, f, dfdu, T_final, N, step_fn, k):

    """ Where k represents: [acceleration burn 1 [m/s^2], acceleration burn 2 [m/s^2], duration burn 1 [s], duration burn 2 [s]] """
    """
    Solve the ODE defined by f and dfdu in time, from initial condition `u_0`
    to final time `T_final`, using `step_fn()` to obtain
    $u_{i+1}$ from $u_i$ at each timestep.  Return array shaped (N+1, M)
    containing the solution u at each time, including t=0.
    """

    """ Six key times are: start burn 1, stop burn 1, start burn 2, stop burn 2 and T Final """
    t1, t2, t3, t4, t5 = 3600, 3600 + k[2], 5 * 3600 * 24, 5 * 3600 * 24 + k[3], T_final

    """ Lists of all timestamps in the simulation (simulation at burn requires smaller dt) """
    ts1 = list(np.arange(0, t1, 100))                   # Stable orbit Earth
    ts2 = list(np.arange(t1, t2, 0.5))                  # Burn 1
    ts3 = list(np.arange(t2, t3, 300))                  # Transfer Orbit
    ts4 = list(np.arange(t3, t4, 0.1))                    # Burn 2
    ts5 = list(np.arange(t4, t5, 300))                  # Stable orbit Moon

    ts = ts1 + ts2 + ts3 + ts4 + ts5                    # ts determines all timestamps in the simulation

    accs = [0] * len(ts1) + [k[0]] * len(ts2) + [0] * len(ts3) + [k[1]] * len(ts4) + [0] * len(ts5)     # Acceleration of satellite at all timestamps

    N = len(ts)
    M = u_0.shape[0]

    u = np.zeros((N + 1, M))
    u[0, :] = u_0

    """ Perform simulation """
    for i in range(N-1):
        dt = ts[i+1]-ts[i]
        u[i + 1, :] = step_fn(u[i, :], f, dfdu, dt, accs[i])
    return u


def f_multibody(u, acc):
    x = u[0:n_body]
    y = u[n_body:2 * n_body]
    xdot = u[2 * n_body:3 * n_body]
    ydot = u[3 * n_body:]
    f = np.zeros((n_body, 4))
    f[:, 0] = xdot
    f[:, 1] = ydot

    """ Add accelerations due to attraction forces """
    for i in range(n_body):
        for j in range(n_body):
            if i != j:
                r = np.sqrt((x[j] - x[i]) ** 2 + (y[j] - y[i]) ** 2)
                f[i, 2] += G * masses[j] * (x[j] - x[i]) / r ** 3
                f[i, 3] += G * masses[j] * (y[j] - y[i]) / r ** 3

    """ Add accelerations due to force generated by burn (same direction as heading) """
    heading = np.arctan2(u[11],u[8])
    f[2, 2] += math.cos(heading) * acc
    f[2, 3] += math.sin(heading) * acc

    return f.T.flatten()

def init_multibody():
    """Initial conditions for Earth-Moon system... and you!"""
    theta = 0                       # Initial angle of circular orbit
    r = 185000 + 6371000            # Radius initial circular orbit
    v = math.sqrt(masses[0]*G/a)    # Velocity of circular orbit

    #        Earth      Moon          You
    return [0,          x_moon,     r*np.cos(theta),   # x-position (Earth at origin)
            0,          0,          r*np.sin(theta),   # y-position
            0,          0,          v * -np.sin(theta),                 # x-vel (center-of-mass stationary)
            vel_earth,  vel_moon,   v * np.cos(theta) ]                 # y-velocity


def rk4(u, f, dfdu, dt, a):
    """
    Runge-Kutta explicit 4-stage scheme - single step.

    Args:
        z (np.array): State at time-step i
        f (function): Fn f defining the ODE
        dt (float): Time-step
    Return:
        z (np.array): State at timestep i+1
    """
    # TODO: Implement RK4
    k1 = dt * f(u, a)
    k2 = dt * f(u + k1 / 2, a)
    k3 = dt * f(u + k2 / 2, a)
    k4 = dt * f(u + k3, a)
    ui_1 = u + (k1 + 2 * k2 + 2 * k3 + k4) / 6

    return ui_1